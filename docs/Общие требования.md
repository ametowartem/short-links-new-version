> **Работа со стейкхолдерами**




**Пользователи**:

- Активные пользователи: люди, которые активно используют сокращенные ссылки для обмена и сокращения длинных URL.

- Коммерческие клиенты: бизнесы, которым требуются сокращенные ссылки для маркетинговых целей или отслеживания эффективности рекламных кампаний.

**Разработчики**:

- Бэкенд разработчики: специалисты, отвечающие за разработку и поддержку серверной части приложения.

- Фронтенд разработчики: разработчики, работающие над пользовательским интерфейсом и клиентской частью приложения.

**Маркетологи**:

- Цифровые маркетологи: специалисты по интернет-маркетингу, которые могут использовать сокращенные ссылки для отслеживания эффективности рекламных кампаний и увеличения конверсии.

**Безопасность и защита данных:**

- Специалисты по информационной безопасности: нужно обеспечить защиту данных пользователей и предотвратить злоупотребление сокращенными ссылками для фишинга или вредоносных целей.


**План взаимодействия с каждой из групп:**

- [ ] Исследование потребностей и ожиданий: Проведение опросов, интервью и анализ рынка, чтобы понять, что именно нужно пользователям и какие функции могут быть востребованы.
- [ ] Разработка продукта: Создание функционала с учетом обратной связи пользователей, обеспечение удобства использования и эффективной работы продукта.
- [ ] Обеспечение безопасности: Разработка и внедрение мер безопасности для защиты данных пользователей и предотвращения злоупотреблений.

\
\
\
\
\
\


**Требования**

1. Функциональные требования

1.1. Создание коротких ссылок
Система должна предоставлять возможность пользователям создавать короткие ссылки, соотнося их с оригинальными URL. Возможность создания коротких ссылок должна быть доступна только авторизованным пользователям.

1.2. Статистика по коротким ссылкам
Пользователям должна быть предоставлена возможность просмотра статистики переходов по каждой короткой ссылке.

1.3. Регистрация и авторизация
Система должна обеспечивать возможность регистрации новых пользователей и аутентификации существующих. Для безопасности доступа к созданию коротких ссылок, необходима аутентификация при каждом запросе на создание новой ссылки.

1.4. Поиск коротких ссылок
Пользователи должны иметь возможность просматривать список созданных ими ссылок.

1.5. Поддержка кастомных ссылок
Система должна позволять пользователям создавать кастомные короткие ссылки, которые могут содержать определенные ключевые слова или фразы.

2. Нефункциональные требования

2.1. Производительность
Система должна обеспечивать высокую производительность при создании и переходе по коротким ссылкам. Задержки не должны превышать несколько миллисекунд.

2.2. Масштабируемость
Система должна быть легко масштабируемой для обеспечения работы с большим объемом коротких ссылок и большим числом пользователей.

2.3. Интерфейс
Интерфейс пользователя должен быть интуитивно понятным и простым в использовании. Должна быть поддержка как веб-интерфейса, так и API для интеграции с другими системами.

2.4. Надежность
Система должна быть надежной и стабильной, минимизируя возможность сбоев и потери данных. Резервное копирование данных и механизмы восстановления должны быть реализованы для предотвращения потери информации.

\
\
\
\
\



> **Атрибуты** **качества**

**Высокая скорость генерации коротких ссылок:**
- [ ] Сценарий: При запросе на сокращение URL время отклика сервера не превышает 100 миллисекунд при нагрузке до 100 запросов в секунду.


**Устойчивость к высокой нагрузке:**
- [ ] Система способна обрабатывать до 1000 запросов в секунду без снижения производительности и без потери данных.

**Безопасность данных пользователей:**
- [ ] Пользовательские данные (пароль) хранятся в зашифрованном виде.

**Простой и удобный интерфейс для пользователей:**
- [ ] Среднее время, затрачиваемое пользователем на создание сокращенной ссылки, не превышает 30 секунд, а процесс создания ссылки интуитивно понятен и не требует дополнительных 

**Отслеживание статистики использования ссылок:**
- [ ] Система предоставляет возможность пользователям просматривать статистику использования сокращенных ссылок, включая количество переходов, время и тип устройства перехода.

**Масштабируемость для возможности роста и развития проекта:**
- [ ] Система легко масштабируется для поддержки роста количества пользователей и объема данных, без необходимости внесения значительных изменений в архитектуру и инфраструктуру.




\
\
\
\
\
\



> **Архитектура и требования**






**Бэкенд**:

1. **NestJS:** Этот фреймворк выбран из-за своей эффективной работы с I/O-bound нагрузкой. NestJS предлагает модульную структуру, встроенную поддержку TypeScript и интеграцию с популярными библиотеками, что облегчает разработку и поддержку серверных приложений.



2. **MongoDB и Mongoose:** Выбор NoSQL базы данных обусловлен отсутствием необходимости в транзакциях и лучшей масштабируемостью для работы с документами. Mongoose обеспечивает удобный доступ к данным MongoDB с помощью схем и моделей.



3. **Redis:** Использование Redis для хранения коротких ссылок обусловлено его быстрой скоростью доступа и возможностью работы с кешем, что позволяет ускорить процесс поиска короткой ссылки.



4. **RabbitMQ:** Отдельный микросервис для подтверждения почты выбран с использованием брокера сообщений RabbitMQ для обеспечения надежной и асинхронной обработки электронной почты.



5. **GraphQL:** Введение GraphQL резолверов для API контроллеров позволяет удобно взаимодействовать между фронтендом и бэкендом, предоставляя клиентам возможность запрашивать только необходимые данные.



6. **ClickHouse:** Планируется использовать ClickHouse для хранения статистики из-за его высокой производительности и возможности анализа больших объемов данных.


7. **Jest и Swagger:** Jest используется для тестирования, а Swagger для создания документации OpenAPI для API.



8. **Mailgun и S3/Minio:** Для отправки почты используется Mailgun, а для хранения изображений - S3 или Minio для обеспечения надежного и масштабируемого хранения.





**Фронтенд:**

1. **React с TypeScript:** Реакт с TypeScript выбран для удобства работы с API сервера и статической типизации данных.



2. **Redux и Apollo:** Redux используется для управления состоянием приложения, а Apollo - для работы с GraphQL запросами.



3. **Axios и SCSS:** Axios используется для отправки HTTP запросов, а SCSS для динамического применения стилей к React компонентам.



4. **Material-UI:** Материал-UI выбран как фреймворк для создания стилизованных компонентов, что упрощает разработку пользовательского интерфейса.





**Инструменты и оркестрация:**

**GitHub:** Используется для хранения и управления кодом.

**Docker и Docker Compose:** Docker и Docker Compose используются для контейнеризации и локальной оркестрации контейнеров, обеспечивая удобство развертывания и масштабирования приложения.







**Альтернативные варианты для бэкенда:**

**Java Spring Boot:**

Почему отказались: Несмотря на схожую архитектуру с NestJS, разработка на Spring Boot может быть более медленной из-за более объемных конфигураций и использования языка Java. Для проекта, где приоритет уделяется скорости разработки и обработки запросов, выбор был сделан в пользу NestJS.


**Python Django:**

Почему отказались: Django имеет меньшую гибкость и сложнее масштабируется по сравнению с NestJS. Также, Python является интерпретируемым языком и неявно типизированным, что может привести к сложностям в разработке и требовать больше тестирования.


**SQL PostgreSQL:**

Почему отказались: PostgreSQL хоть и обладает высокой отказоустойчивостью и безопасностью за счет использования SQL и транзакций, но он медленнее в работе и сложнее масштабируется по сравнению с MongoDB. Для проекта, где важна скорость обработки запросов, выбрана MongoDB.

**Kafka:**

Почему отказались: Kafka имеет более сложную настройку и администрирование, чем RabbitMQ. Также, для небольших проектов Kafka может быть избыточным и излишне сложным решением.

**ELK Stack:**

Почему отказались: ELK Stack обладает мощными возможностями для обработки и анализа логов, однако ClickHouse более подходит для хранения и анализа статистических данных в реальном времени. ELK Stack также требует больше ресурсов для настройки и обслуживания.

**Nodemailer:**

Почему отказались: Mailgun предоставляет более простое и надежное решение для отправки почты в рамках проекта, в то время как Nodemailer требует больше настроек и может быть менее надежным.


**Альтернативные варианты для фронтенда:**

**Angular или Next.js:**

Почему отказались: Angular и Next.js имеют большой порог входа и более сложные концепции по сравнению с React. Для проекта, где важны быстрое время разработки и гибкость, выбран React.

**MobX:**

Почему отказались: MobX имеет более сложную структуру и управление состоянием по сравнению с Redux. Redux широко используется в индустрии и обладает большим сообществом поддержки и экосистемой.

**Bootstrap:**

Почему отказались: MUI предоставляет более гибкие и стилизованные компоненты специально для React, что делает его более удобным для разработки интерфейса в среде React. Bootstrap, с другой стороны, имеет более общий подход и может требовать больше настроек для интеграции с React.




\
\
\
\
\
\



> **Паттерны проектирования**




**Dependency Injection (DI):**

- Описание: DI в NestJS позволяет инжектировать зависимости в классы и компоненты вместо того, чтобы жестко зависеть от них.
- Пример использования: Используем декоратор @Injectable() для классов сервисов, провайдеров, резолверов, репозиториев и т.д.

**singleton:**

- Описание: Синглтоны в NestJS позволяют создавать единственный экземпляр сервиса, который будет использоваться повторно в приложении.
- Пример использования: Смежный с предыдущим паттерном - по умолчанию сервисы в NestJS являются синглтонами, что означает, что для каждого запроса будет использоваться один и тот же экземпляр сервиса.

**Guard:**

- Описание: Guards в NestJS позволяют контролировать доступ к рутам в контроллере на основе стратегий (авторизация пользователей, роли )
- Пример использования: Для REST API контроллера и для graphQL резолвера реализовали отдельные гварды, которые достают из контекста JWT токен, расшифровывается и определяется, должен ли запрос быть разрешен или нет. Применяется с помощью декоратора @UseGuards().

**Pipe:**

- Описание: Pipes в NestJS используются для валидации и преобразования данных, поступающих в контроллеры.
- Пример использования: используем глобальный ValidationPipe для валидации dto поступающих в контроллеры 

**Декораторы:**

- Описание: Декораторы в NestJS используются для добавления метаданных к классам, методам или свойствам и для определения их поведения.
- Пример использования: Например, создаем модули с помощью @Module, сервисы с @Injectable, получаем body запроса с помощью @Body и @Args, инджектим экземпляры клиентов, сервисов и т.д. с помощью @Inject, валидируем dto с помощью @IsString, @IsEmail, IsNotNull, IsOptional

**Фабричные методы для создания модулей:**

- Описание: В NestJS фабричные методы используются для создания экземпляров модулей и их конфигурации.
- Пример использования: инициализируем модули с помощью фабричных методов и useFactory (например, MailgunProvider для создания экземпляров для взаимодействия с почтой и RedisProvider для создания экземпляров для взаимодействия с кешем с помощью redis)

**proxy:**

- Описание: В NestJS можно использовать встроенный механизм клиентов прокси для взаимодействия с другими микросервисами.
- Пример использования: После инициализации RabbitMQ модуля для взаимодействия с микросервисом инджектится клиент с типом ClientProxy



\
\
\
\
\
\




> **Системы контроля версий**



На нашем проекте мы используем методологию Feature Branching для управления нашим процессом разработки. Этот подход оказался идеальным для нашего небольшого проекта, потому что он обеспечивает простоту, гибкость и эффективность в управлении изменениями.

Мы выбрали Feature Branching из-за его простоты. Там используется только одна ветка main, вокруг которой вращается весь процесс разработки. Это упрощает работу с репозиторием и ускоряет процесс разработки.

Одним из ключевых преимуществ Feature Branching является его гибкость. Мы можем легко создавать новые ветки для различных функций, исправлений и экспериментов. Например, недавно мы перешли от монолитной архитектуры к микросервисной, и Feature Branching дает нам возможность легко управлять этими изменениями (создали отдельную ветку microservice, пулл реквестнули коммиты по ветке, провели код ревью, затем смерджили в main ветку новый pull request).

Важным аспектом Feature Branching для нас является также поддержка непрерывной интеграции и развертывания. Мы можем автоматизировать тестирование и развертывание наших изменений, что позволяет нам быстрее выявлять и исправлять проблемы.

Кроме того, Feature Branching требует, чтобы каждый пул-реквест проходил через процесс код-ревью, что повышает качество кода. Это помогает нам обнаруживать и исправлять потенциальные проблемы и недочеты в коде до его слияния в основную ветку.

В целом, Feature Branching подход идеально сочетается с нашим проектом по созданию коротких ссылок, обеспечивая простоту, гибкость и эффективность в управлении нашим процессом разработки.





\
\
\
\
\


> **Стабильность кода**



- [ ] **Линтеры Prettier и ESLint:**

Мы используем линтеры Prettier и ESLint для автоматической проверки и форматирования кода в соответствии с их конфигурацией. Эти инструменты помогают обнаруживать и исправлять структурные и стилистические ошибки в коде, что способствует его читаемости и поддерживаемости.

- [ ] **Настройка GitHub Actions (CI/CD):**

Мы настроили GitHub Actions для автоматической сборки, тестирования и развертывания нашего проекта при каждом пул-реквесте в мастер ветку с новой функцией. Это позволяет нам оперативно обнаруживать и исправлять проблемы в коде на ранних стадиях разработки, обеспечивая его стабильность и надежность.

- [ ] **Интеграция линтеров и тестов в процесс сборки:**

В процессе сборки на GitHub Actions мы интегрировали проверку и форматирование кода с помощью линтеров Prettier и ESLint. Также запускаются тесты, которые проверяют корректность работы новой функциональности. Это позволяет нам убедиться, что новые изменения соответствуют стандартам качества кода и не вызывают непредвиденных проблем.




\
\
\
\
\
\



> **Сценарии тестирования**



**Тест-сьюты:**


**Таблица 1. Список тест-сьютов**


| ID | Автор | Приоритет | Заголовок                            | Список тест-кейсов     |
|----|-------|-----------|--------------------------------------|------------------------|
| 1  | user  | 2         | Аутентификация                       | 1.1 Авторизация        |
|    |       |           |                                      | 1.2 Регистрация        |
| 2  | user  | 2         | Сервис авторизации                   | 2.1 Авторизация пользователя |
|    |       |           |                                      | 2.2 Ошибка авторизации |
| 3  | user  | 1         | Создание ссылки                      | 3.1 Позитивный сценарий |
|    |       |           |                                      | 3.2 Негативный сценарий |
| 4  | user  | 1         | Получение ссылки                     | 4.1 Позитивный сценарий |
|    |       |           |                                      | 4.2 Негативный сценарий |
| 5  | user  | 2         | Получение списка ссылок пользователя | 5.1 Позитивный сценарий |
|    |       |           |                                      | 5.2 Негативный сценарий |
| 6  | user  | 2         | Поиск пользователя                   | 6.1 Поиск по ID        |
|    |       |           |                                      | 6.2 Поиск по имени     |
|    |       |           |                                      | 6.3 Поиск всех пользователей |
| 7  | user  | 3         | Управление пользователями            | 7.1 Регистрация нового пользователя |
|    |       |           |                                      | 7.2 Изменение данных пользователя |
|    |       |           |                                      | 7.3 Удаление пользователя |
|    |       |           |                                      | 7.4 Добавление аватара пользователя |
|    |       |           |                                      | 7.5 Получение аватара пользователя |
|    |       |           |                                      | 7.6 Добавление почты пользователю |
|    |       |           |                                      | 7.7 Подтверждение почты пользователя |
| 8  | user  | 2         | Управление ссылками пользователя                 | 8.1 Добавление короткой ссылки |
|    |       |           |                                      | 8.2 Получение списка ссылок пользователя |

**Тест-кейсы:**


**Таблица 2. Список тест-кейсов**




| ID  | Описание                            | Предусловия                             | Шаги                                      | Ожидаемый результат                         |
|-----|-------------------------------------|------------------------------------------|-------------------------------------------|---------------------------------------------|
| 1.1 | Авторизация (позитивный)           | Пользователь не авторизован в системе    | 1. Пользователь вводит свой логин и пароль | Пользователь успешно авторизован            |
| 1.2 | Регистрация (негативный)           | Пользователь не зарегистрирован в системе | 1. Пользователь вводит существующий в системе email | Выводится сообщение о существующем пользователе |
| 2.1 | Авторизация пользователя (позитивный) | Пользователь зарегистрирован в системе | 1. Пользователь вводит свой логин и пароль | Пользователь успешно авторизован            |
| 2.2 | Ошибка авторизации (негативный)   | Пользователь вводит неверные учетные данные | 1. Пользователь вводит неправильный логин и/или пароль | Выводится сообщение об ошибке аутентификации |
| 3.1 | Создание ссылки (позитивный)      | Пользователь хочет создать короткую ссылку | 1. Пользователь предоставляет длинную ссылку и свой ID | Ссылка успешно создана                      |
| 3.2 | Создание ссылки (негативный)      | Пользователь хочет создать короткую ссылку | 1. Пользователь предоставляет некорректные данные | Возвращается сообщение об ошибке            |
| 4.1 | Получение ссылки (позитивный)     | Ссылка существует в системе               | 1. Пользователь запрашивает короткую ссылку | Возвращается длинная ссылка                 |
| 4.2 | Получение ссылки (негативный)     | Ссылка не существует в системе            | 1. Пользователь запрашивает короткую ссылку | Возвращается сообщение об отсутствии ссылки  |
| 5.1 | Получение списка ссылок пользователя (позитивный) | Пользователь имеет созданные короткие ссылки | 1. Пользователь запрашивает список своих коротких ссылок | Возвращается список коротких ссылок пользователя |
| 5.2 | Получение списка ссылок пользователя (негативный) | Пользователь не имеет созданных коротких ссылок | 1. Пользователь запрашивает список своих коротких ссылок | Возвращается сообщение о отсутствии ссылок у пользователя |
| 6.1 | Поиск пользователя по ID          | Пользователь хочет найти пользователя по ID | 1. Пользователь предоставляет ID пользователя | Возвращается пользователь с указанным ID    |
| 6.2 | Поиск пользователя по имени       | Пользователь хочет найти пользователя по username | 1. Пользователь предоставляет имя пользователя | Возвращается пользователь с указанным именем |
| 6.3 | Поиск всех пользователей          | Пользователь хочет найти всех пользователей | 1. Пользователь запрашивает список всех пользователей | Возвращается список всех пользователей       |
| 7.1 | Регистрация нового пользователя   | Пользователь хочет зарегистрироваться    | 1. Пользователь предоставляет данные для регистрации | Создается новый пользователь                |
| 7.2 | Изменение данных пользователя     | Пользователь хочет изменить данные профиля | 1. Пользователь предоставляет новые данные пользователя | Данные пользователя успешно изменены        |
| 7.3 | Удаление пользователя             | Пользователь хочет удалить пользователя  | 1. Пользователь предоставляет ID пользователя | Пользователь успешно удален                |
| 7.4 | Добавление аватара пользователя | Пользователь хочет добавить аватар-картинку | 1. Пользователь предоставляет файл аватара и свой ID | Аватар успешно добавлен и связан с пользователем |
| 7.5 | Получение аватара пользователя   | Пользователь имеет установленный аватар | 1. Пользователь запрашивает свой аватар | Возвращается файл аватара пользователя     |
| 7.6 | Добавление почты пользователю     | Пользователь хочет добавить почту        | 1. Пользователь предоставляет свою почту и свой ID | Почта успешно добавлена                     |
| 7.7 | Подтверждение почты пользователю  | Пользователь предоставил почту и верификацию | 1. Пользователь предоставляет код верификации и свой ID | Почта пользователя успешно подтверждена    |
| 8.1 | Добавление короткой ссылки       | Пользователь создал короткую ссылку     | 1. Пользователь предоставляет длинную ссылку и свой ID | Короткая ссылка добавляется к записи пользователя в БД |
| 8.2 | Получение списка ссылок пользователя | Пользователь имеет созданные короткие ссылки | 1. Пользователь запрашивает список своих коротких ссылок | Возвращается список коротких ссылок пользователя |



\
\
\
\
\
\




> **Работа с изменениями**





Поступление задачи: от заказчика или команды приходит требование по добавлению новой фичи или исправлению бага

1. Тимлид (@ametowartem) выставляет требование к изменению конкретного функционала (в случае с багом) или добавления нового функционала (в случае с новой фичей)

2. Затем, тимлид вместе с разработчиком обсуждает этапы фикса бага или добавления новой фичи

3. Разработчик создает отдельную ветку с названием fix/{название фичи} (в случае с багом) или feature/{название фичи} (в случае с новой фичей)

4. Разработчик устраняет баг и делает pull request в репозиторий

5. Тимлид (@ametowartem) делает code review, указывает на недочеты, после чего код отправляется на доработку или аппрувается тимлидом и допускается до тестирования в github activity на линтеры и тесты

6. После успешного прохождения этапа тестирования ветка с фиксом мерджится в мастер ветку




\
\
\
\
\
\



>  **Рефакторинг**




В нашем проекте мы применяем различные методы рефакторинга старого кода для улучшения читаемости и упрощения дальнейшей работы с кодом

**Вот пример примененных нами техник:**

- Использование линтеров: Линтеры автоматически анализируют код на предмет соответствия стандартам кодирования и выявляют потенциальные проблемы. Применение линтеров позволяет выявить структурные или стилистические недочеты в коде и обеспечить единообразие стиля кодирования в проекте.

- Метод извлечения: В основном мы применяем его в реакт части - этот метод рефакторинга помогает улучшить читаемость и модульность кода путем разбиения больших реакт компонентов на более мелкие и самодостаточные части. Это упрощает поддержку и повторное использование кода, поскольку маленькие компоненты могут быть легко переиспользованы в различных частях проекта.

- Метод слияния дублированного кода: Если мы видим, что часть кода часто повторяется в различных функциях мы используем эту технику. Она помогает в устранении дублированного кода, помогает уменьшить объем кода, делает его более понятным и облегчает его поддержку. Вынос повторяющихся фрагментов кода в отдельные функции или модули позволяет избежать ошибок и ускоряет разработку нового функционала.

- Упрощение методов: Если классы или функции выполняют слишком много разноплановых действий (становятся классами Бога), их следует разбить на более мелкие и тематические модули или сервисы. Это повышает модульность и понятность кода, облегчает его тестирование и поддержку, а также снижает вероятность ошибок при разработке.



\
\
\
\
\



> **Развертывание ПО**




В нашем проекте мы используем docker для контейнеризации проекта и docker-compose для локальной оркестрации баз данных и прочих микросервисов для упрощения разработки
